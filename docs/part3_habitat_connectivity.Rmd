---
title: 'Part3: convervation status analysis'
author: "Lei Song"
date: "7/27/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
library(here)
library(terra)
library(ggplot2)
library(dplyr)
library(stars)

data_path <- here("data")
result_path <- here("results")
vct_path <- file.path(data_path, "vectors")
rst_path <- file.path(data_path, "rasters")
pat_path <- file.path(data_path, "vars_patch")
cnt_path <- file.path(data_path, "connectivity")
cnt_exp_path <- file.path(result_path, "connectivity")
```

## Habitat clusters

Overlap the convex hull of census blocks and expert range map to make the habitat clusters. These clusters will be used to model the long-distance habitat connectivity between them.

There would be three clusters:

- North
- Southwest
- Southeast

```{r}
# Habitat clusters
habitat_clusters <- read_sf(
    file.path(data_path, "observations/habitat_clusters.geojson"))

habitat_clusters <- do.call(
    rbind, lapply(unique(habitat_clusters$cluster), 
                  function(index) {
        habitat_clusters %>% filter(cluster == index) %>% 
            st_union() %>% st_convex_hull() %>% 
            st_as_sf(cluster = index) %>% 
            rename(geometry = x)
}))

# Overlap with expert range map
range_map <- read_sf(
    file.path(data_path, "observations/range_map.geojson"))

habitat_clusters <- st_intersection(range_map, habitat_clusters) %>% 
    mutate(area = st_area(.) %>% units::set_units("km2")) %>% 
    filter(area > 10000 %>% units::set_units("km2")) %>% 
    arrange(cluster) %>% 
    mutate(name = c("North", "Southeast", "Southwest")) %>% 
    select(cluster, name)

write_sf(habitat_clusters, 
         file.path(data_path, "observations",
                   "habitat_clusters_aggre.geojson"))

# Rasterize the clusters
template <- read_stars(
    file.path(result_path, "landscape_utility_1km_integrated.tif")) %>% 
    split() %>% select(prediction)
template <- template %>% mutate("prediction" = -9999)

habitat_clusters <- st_rasterize(habitat_clusters, template)
write_stars(habitat_clusters, 
            file.path(cnt_path, "habitat_clusters.tif"),
            type = "Byte", NA_value = -9999)
```

## Habitat connectivity

Based on the habitat clusters: north, southwest, southeast. Then:

- Analyze the connectivity between these three big habitat clusters.
- Analyze the connectivity between small habitat patches within each habitat clusters.

#### Movement masks

There are not many natural barriers for African elephants to move around savannas because elephant can adapt to a wide range of climate and they can swim or hike. Because elephants are good swimmer and they can swim as far as over 20 miles, so we did not include water as barriers.

Anthropological barriers

- Farmlands (done)
- Dense settlements (done)

Then get farmland and savanna proportion and rasterize mountain elevation.

```{r}
# Farmland and savanna
vars <- rast(file.path(pat_path, "variables.tif"))
cropland <- subset(vars, "cropland_ratio_3")

writeRaster(cropland, file.path(cnt_path, "cropland_ratio.tif"))
```

The get the settlement density with a moving window 3 by 3.

```{r}
# Cut the whole image to tiles
# I guess large vector can slow down the computation significantly
template <- rast(file.path("data/vars_patch", "bio4.tif"),
                 lyrs = 1)
values(template) <- NA
parts <- aggregate(template, fact = 60)
temp_dir <- tempdir()
output_tiles <- makeTiles(
    template, parts,
    filename = file.path(temp_dir, 'output_.tif'))
rm(temp_dir, parts, template)

# Summarize the settlement count within each cell tile by tile
temp_dir <- file.path(tempdir(), "results_settlement")
dir.create(temp_dir)
message('Save raster chunks to %s', temp_dir)

settlement_density <- pbmclapply(output_tiles, function(fname) {
    bry <- read_sf(
        file.path("/Users/pinot/Dropbox/research/eleDistribution",
                  "data/vectors/mainland_tanzania.geojson")) %>% 
        select()
    id <- as.polygons(rast(fname) %>% ext(), crs = "epsg:4326") %>% 
        st_as_sf() %>% st_intersects(bry) %>% unlist()
    if (length(id) != 0) {
        outname <- file.path(temp_dir, basename(fname))
        rst <- rast(fname)
        vct <- crop(vect(buildings), rst)
        if (nrow(vct) == 0) {
            values(rst) <- 0
            writeRaster(rst, outname)
        } else {
            rst <- rasterizeGeom(vct, rst, fun = "count")
            writeRaster(rst, outname)
        }
        rm(rst, vct); gc()
        outname
    } else fname
}, mc.cores = 7, ignore.interactive = TRUE)
settlement_density <- vrt(unlist(settlement_density))
writeRaster(settlement_density, 
            file.path("data/connectivity", "settlement_density.tif"))
```

#### Prepare connectivity modeling data

First, increase the suitability of savanna as a main habitat, then:

- Run a base model
- Add farmlands and settlements barriers (different levels)

```{r}
# Make spatial files
# 1. Make the original suitability under current condition as reference
suitability <- rast(
    file.path(result_path, "landscape_utility_1km_integrated.tif"),
    lyrs = 1)
suitability[is.na(suitability)] <- -9999
writeRaster(suitability, file.path(cnt_path, 'suitability_original.asc'),
            wopt = list(NAflag = -9999))

# Habitat clusters
habitat_clusters <- rast(file.path(cnt_path, "habitat_clusters.tif"))
habitat_clusters[habitat_clusters == 0] <- -9999
writeRaster(habitat_clusters, 
            file.path(cnt_path, 'habitat_clusters_original.asc'),
            wopt = list(NAflag = -9999))

# 2. Suitability with settlement and cropland as barriers
settlement <- rast(file.path(cnt_path, "settlement_density.tif"))
settlement <- settlement > 400 # big town
cropland <- rast(file.path(cnt_path, "cropland_ratio.tif"))
# Very conservative. 
# Assume elephants would take the risk if there is no choice.
cropland <- cropland > 0.8 
msk <- (settlement + cropland) >= 1
msk[msk == 0] <- NA

suitability <- rast(
    file.path(result_path, "landscape_utility_1km_integrated.tif"),
    lyrs = 1)
suitability <- mask(suitability, msk, inverse = TRUE,
                    updatevalue = 0)
writeRaster(suitability, file.path(cnt_path, 'suitability_human_block.tif'))

# Write asc
suitability[is.na(suitability)] <- -9999
writeRaster(suitability, file.path(cnt_path, 'suitability_human_block.asc'),
            wopt = list(NAflag = -9999))

# Habitat clusters
habitat_clusters <- rast(file.path(cnt_path, "habitat_clusters.tif"))
habitat_clusters <- mask(habitat_clusters, msk, inverse = TRUE,
                         updatevalue = 0)
habitat_clusters[habitat_clusters == 0] <- -9999
writeRaster(habitat_clusters, 
            file.path(cnt_path, 'habitat_clusters_human_block.asc'),
            wopt = list(NAflag = -9999))

# 3. Suitability with settlement and all cropland as barriers
# Just consider cropland
settlement <- rast(file.path(cnt_path, "settlement_density.tif"))
settlement <- settlement > 200 # a future big town
cropland <- rast(file.path(cnt_path, "cropland_ratio.tif"))
# Very conservative. 
# Assume elephants would take the risk if there is no choice.
cropland <- cropland > 0.2 
msk <- (settlement + cropland) >= 1
msk[msk == 0] <- NA

suitability <- rast(
    file.path(result_path, "landscape_utility_1km_integrated.tif"),
    lyrs = 1)
suitability <- mask(suitability, msk, inverse = TRUE,
                    updatevalue = 0)
writeRaster(suitability, 
            file.path(cnt_path, 'suitability_human_block_complete.tif'))

# Write asc
suitability[is.na(suitability)] <- -9999
writeRaster(suitability, 
            file.path(cnt_path, 'suitability_human_block_complete.asc'),
            wopt = list(NAflag = -9999))

# Habitat clusters
habitat_clusters <- rast(file.path(cnt_path, "habitat_clusters.tif"))
habitat_clusters <- mask(habitat_clusters, msk, inverse = TRUE,
                         updatevalue = 0)
habitat_clusters[habitat_clusters == 0] <- -9999
writeRaster(habitat_clusters, 
            file.path(cnt_path, 'habitat_clusters_human_block_complete.asc'),
            wopt = list(NAflag = -9999))
```

#### Long-distance landscape connectivity

Prepare config files for circuitscape, and then run the experiments.

```
library(JuliaCall)
julia_setup(installJulia = TRUE)
julia_install_package_if_needed("Circuitscape")
julia_library("Circuitscape")
julia_command(sprintf('compute("%s")', fname))
```

```{r}
# install.packages("ini")
library(ini)
library(purrr)
# write out the configuration files
config <- read.ini(file.path(cnt_path, "circuitscape_setting_template.ini"))
fnames <- list.files(cnt_path, pattern = "suitability.*\\.asc$",
                     full.names = TRUE)

# set up Julia
library(JuliaCall)
# julia_setup(installJulia = TRUE)
julia_install_package_if_needed("Circuitscape")
julia_library("Circuitscape")

walk(fnames, function(fn) {
    # Define the name for the run
    nm <- gsub("suitability_", "", fs::path_ext_remove(basename(fn)))
    message(sprintf("Run experiment for the case: %s.", nm))
    
    # Revise the config parameters
    config$`Output options`$output_file <-
        file.path(cnt_exp_path, nm)
    config$`Logging Options`$log_file <-
        file.path(cnt_exp_path, sprintf("%s.log", nm))
    config$`Options for pairwise and one-to-all and all-to-one modes`$point_file <-
        file.path(cnt_path, sprintf('habitat_clusters_%s.asc', nm))
    config$`Habitat raster or graph`$habitat_file <- fn
    fname <- file.path(cnt_path, sprintf("%s.ini", nm))
    write.ini(config, fname)
    
    if (file.exists(fname)) {
        julia_command(sprintf('compute("%s")', fname))
    } else {
        warning("Failed to write out config file.")
    }
})

# Gather results and compare
```

#### Short-distance landscape connectivity within clusters

Overlap the PAs and habitat clusters.

```{r}
pas <- read_sf(file.path(vct_path, "wdpa_selected.geojson")) %>% 
    filter(DESIG_ENG %in% c("Game Reserve", "National Park",
                            "Game controlled area", "Conservation Area",
                            "Open area", "Wildlife Management Area"))
habitat_clusters <- read_sf(file.path(data_path, "observations",
                                      "habitat_clusters_aggre.geojson"))
pas <- pas %>% slice(unique(unlist(st_intersects(habitat_clusters, pas))))
pas <- st_join(pas, habitat_clusters) %>% 
    mutate(park_name = NAME) %>% 
    select(cluster, name, park_name)
write_sf(pas, file.path(cnt_path, "pas.geojson"))
```

Randomly generate one 5km habitat point within each PA, and then connect them by graph theory (circuitscape). Run this for 50 iteration to target the hotpots.

```
Rscript scripts/circt_points_cli.R -c no_of_cluster -n 50
```

## Analysis the results
### Long-distance connectivity between habitat clusters

```{r}
# Normalize current
norm_rast <- function(s){
    minmax(s, compute = TRUE)
    nx <- minmax(s)    
    (s - nx[1,]) / (nx[2,] - nx[1,])
}

# Read habitat clusters and accumulated current maps
habitat_clusters <- rast(file.path(
    cnt_path, "habitat_clusters_human_block.asc"))
curmap_block <- rast(file.path(cnt_exp_path, "human_block_cum_curmap.asc"))
curmap_block <- mask(curmap_block, habitat_clusters, 
                     inverse = TRUE, updatevalue = NA)
curmap_block <- norm_rast(curmap_block)
writeRaster(curmap_block, 
            file.path(cnt_exp_path, "connectivity_scenario1.tif"))

habitat_clusters <- rast(file.path(
    cnt_path, "habitat_clusters_human_block_complete.asc"))
curmap_block_complete <- rast(
    file.path(cnt_exp_path, "human_block_complete_max_curmap.asc"))
curmap_block_complete <- mask(curmap_block_complete, habitat_clusters, 
                              inverse = TRUE, updatevalue = NA)
curmap_block_complete <- norm_rast(curmap_block_complete)
writeRaster(curmap_block_complete, 
            file.path(cnt_exp_path, "connectivity_scenario2.tif"))

## Read farmlands and settlements under different scenarios
settlement <- rast(file.path(cnt_path, "settlement_density.tif"))
cropland <- rast(file.path(cnt_path, "cropland_ratio.tif"))

# Scenario 1
cropland_s1 <- cropland > 0.8
settlement_s1 <- settlement > 400
settlement_s1[isTRUE(settlement_s1)] <- 2
humans_s1 <- sum(cropland_s1, settlement_s1, na.rm = TRUE)
writeRaster(humans_s1, file.path(cnt_path, "blocks_s1.tif"))

# Scenario 2
cropland_s2 <- cropland > 0.2
settlement_s2 <- settlement > 200
settlement_s2[isTRUE(settlement_s2)] <- 2
humans_s2 <- sum(cropland_s2, settlement_s2, na.rm = TRUE)
writeRaster(humans_s2, file.path(cnt_path, "blocks_s2.tif"))
```

#### Potential corridors (current and future) between habitat clusters

Get the "least-cost-path" for each case to compare the level of difficulty for each potential path.

```{r}
library(gdistance)

# Read the coordinates and "cost" to calculate the LSP
link_points <- read_sf(file.path(cnt_exp_path, "link_points.shp"))
coords <- cbind(link_points %>% st_drop_geometry(),
                st_coordinates(link_points))
connt_sca1 <- rast(file.path(cnt_exp_path, "connectivity_scenario1.tif"))
connt_sca1[is.na(connt_sca1)] <- 0
tr <- transition(raster(connt_sca1), transitionFunction = mean, directions = 16)

pairs <- list(c(1, 2), c(5, 10), c(3, 4), c(6, 7), c(8, 9))
names(pairs) <- c("cluster13", "cluster23_1", "cluster23_2", 
                  "cluster12_1", "cluster12_2")
lcps_sca1 <- do.call(rbind, lapply(pairs, function(pair){
    coords_pair <- as.matrix(coords[pair, c("X", "Y")])
    
    lcp <- shortestPath(
        tr, coords_pair[1, ], coords_pair[2, ], 
        output = "SpatialLines")
    st_as_sf(lcp) %>% mutate(path = names(pair))
}))

connt_sca2 <- rast(file.path(cnt_exp_path, "connectivity_scenario2.tif"))
connt_sca2[is.na(connt_sca2)] <- 0
tr <- transition(raster(connt_sca2), transitionFunction = mean, directions = 16)

pairs <- list(c(5, 10), c(3, 4), c(6, 7), c(8, 9))
names(pairs) <- c("cluster23_1", "cluster23_2", 
                  "cluster12_1", "cluster12_2")
lcps_sca2 <- do.call(rbind, lapply(pairs, function(pair){
    coords_pair <- as.matrix(coords[pair, c("X", "Y")])
    
    lcp <- shortestPath(
        tr, coords_pair[1, ], coords_pair[2, ], 
        output = "SpatialLines")
    st_as_sf(lcp) %>% mutate(path = names(pair))
}))

fname <- file.path(cnt_exp_path, "potential_corridors_scenario1.geojson")
write_sf(lcps_sca1, fname)
fname <- file.path(cnt_exp_path, "potential_corridors_scenario2.geojson")
write_sf(lcps_sca2, fname)

# Conservation suggestions
## Protected areas
library(classInt)
library(rmapshaper)
current_map_s2 <- read_stars(
    file.path(cnt_exp_path, "connectivity_scenario2.tif"))
# Get cuts
values <- as.data.frame(current_map_s2) %>% na.omit() %>% pull(3)
values <- values[values >= quantile(values, 0.02) & 
                     values <= quantile(values, 0.98)]
breaks_s2 <- classIntervals(round(values, 3), 
                         n = 7, style = "equal")
corridor_s2 <- current_map_s2 > breaks_s2$brks[5]
corridor_s2[corridor_s2 == 0] <- NA
corridor_s2 <- st_as_sf(corridor_s2, merge = TRUE, na.rm = TRUE) %>% 
    mutate(area = st_area(.) %>% units::set_units("km2")) %>% 
    filter(area > 500 %>% units::set_units("km2")) %>% 
    select(-area) %>% 
    ms_simplify(keep = 0.1) %>% st_make_valid()

current_map_s1 <- read_stars(
    file.path(cnt_exp_path, "connectivity_scenario1.tif"))
# Get cuts
values <- as.data.frame(current_map_s1) %>% na.omit() %>% pull(3)
values <- values[values >= quantile(values, 0.02) & 
                     values <= quantile(values, 0.98)]
breaks_s1 <- classIntervals(round(values, 3), 
                         n = 7, style = "equal")
corridor_s1 <- current_map_s1 > breaks_s1$brks[5]
corridor_s1[corridor_s1 == 0] <- NA
corridor_s1 <- st_as_sf(corridor_s1, merge = TRUE, na.rm = TRUE) %>% 
    mutate(area = st_area(.) %>% units::set_units("km2")) %>% 
    filter(area > 500 %>% units::set_units("km2")) %>% 
    select(-area) %>% 
    ms_simplify(keep = 0.1) %>% st_make_valid()

corridor_s1 <- corridor_s1 %>% mutate(type = "Community based") %>% 
            select(type) %>% mutate(id = 1:nrow(.))
write_sf(corridor_s1, file.path(cnt_exp_path, "community_based.geojson"))

corridor_s2 <- corridor_s2 %>% mutate(type = "Protected area") %>% 
    select(type) %>% mutate(id = 1:nrow(.))
write_sf(corridor_s2, file.path(cnt_exp_path, "protected_area.geojson"))
```

#### Path analysis for the corridors between habitat clusters

```{r}
library(ggridges)
library(tidyr)
select <- dplyr::select

# NDVI dry season, NDVI wet season, elevation
elevation <- rast(file.path(rst_path, "dsm_tanzania_1km.tif"))
ndvi_dry <- rast(file.path(
    data_path, "NDVI","lansat8_sr_13_19_dry_NDVI_mean_1000m.tif")) %>% 
    resample(elevation)
ndvi_wet <- rast(file.path(
    data_path, "NDVI","lansat8_sr_13_19_wet_NDVI_mean_1000m.tif")) %>% 
    resample(elevation)
cropland_ratio <- rast(file.path(cnt_path, "cropland_ratio.tif"))
vars <- c(elevation, ndvi_dry, ndvi_wet, cropland_ratio)
rm(elevation, ndvi_dry, ndvi_wet, cropland_ratio)
names(vars) <- c("Elevation", "NDVI (dry season)", 
                 "NDVI (wet season)", "Cropland coverage")

lcps_sca1 <- read_sf(
    file.path(cnt_exp_path, "potential_corridors_scenario1.geojson"))
lcps_sca1 <- lcps_sca1 %>% 
    mutate(id = 1:nrow(.))

lcps_sca1_statistics <- lapply(lcps_sca1$id, function(index){
    if (index %in% 1:3){
        terra::extract(
            vars, 
            lcps_sca1 %>% filter(id == index) %>% vect(),
            xy = TRUE) %>% 
            arrange(-y) %>% mutate(lat = y) %>% 
            mutate(id = 1:nrow(.)) %>% 
            select(lat, Elevation, "NDVI (dry season)", 
                   "NDVI (wet season)", "Cropland coverage") %>% 
            pivot_longer(cols = c("Elevation", "NDVI (dry season)", 
                                  "NDVI (wet season)", "Cropland coverage"),
                         names_to = "variable", values_to = "value")
    } else {
        terra::extract(
            vars, 
            lcps_sca1 %>% filter(id == index) %>% vect(),
            xy = TRUE) %>% 
            arrange(-x) %>% mutate(lon = x) %>% 
            mutate(id = 1:nrow(.)) %>% 
            select(lon, Elevation, "NDVI (dry season)", 
                   "NDVI (wet season)", "Cropland coverage") %>% 
            pivot_longer(cols = c("Elevation", "NDVI (dry season)", 
                                  "NDVI (wet season)", "Cropland coverage"),
                         names_to = "variable", values_to = "value")
    }
})

save(lcps_sca1_statistics, 
     file = file.path(cnt_exp_path, "corridors_sca1_statistics.rda"))

lcps_sca2 <- read_sf(
    file.path(cnt_exp_path, "potential_corridors_scenario2.geojson"))
lcps_sca2 <- lcps_sca2 %>% 
    mutate(id = 1:nrow(.))

lcps_sca2_statistics <- lapply(lcps_sca2$id, function(index){
    if (index %in% 1:2){
        terra::extract(
            vars, 
            lcps_sca2 %>% filter(id == index) %>% vect(),
            xy = TRUE) %>% 
            arrange(-y) %>% mutate(lat = y) %>% 
            mutate(id = 1:nrow(.)) %>% 
            select(lat, Elevation, "NDVI (dry season)", 
                   "NDVI (wet season)", "Cropland coverage") %>% 
            pivot_longer(cols = c("Elevation", "NDVI (dry season)", 
                                  "NDVI (wet season)", "Cropland coverage"),
                         names_to = "variable", values_to = "value")
    } else {
        terra::extract(
            vars, 
            lcps_sca2 %>% filter(id == index) %>% vect(),
            xy = TRUE) %>% 
            arrange(-x) %>% mutate(lon = x) %>% 
            mutate(id = 1:nrow(.)) %>% 
            select(lon, Elevation, "NDVI (dry season)", 
                   "NDVI (wet season)", "Cropland coverage") %>% 
            pivot_longer(cols = c("Elevation", "NDVI (dry season)", 
                                  "NDVI (wet season)", "Cropland coverage"),
                         names_to = "variable", values_to = "value")
    }
})

save(lcps_sca2_statistics, 
     file = file.path(cnt_exp_path, "corridors_sca2_statistics.rda"))
```

### Short-distance connectivity within each habitat cluster

```{r}
pas <- read_sf(file.path(cnt_path, "pas.geojson"))

## Read farmlands and settlements under different scenarios
settlement <- rast(file.path(cnt_path, "settlement_density_3.tif"))
cropland <- rast(file.path(cnt_path, "cropland_ratio.tif"))
mountains <- rast(file.path(cnt_path, "mountains_spath.tif"))
mountains[mountains == 1] <- 4

# Scenario 1
cropland_s1 <- cropland > 0.9
settlement_s1 <- settlement > 400
settlement_s1[isTRUE(settlement_s1)] <- 2
humans_s1 <- sum(cropland_s1, settlement_s1, na.rm = TRUE)
humans_s1 <- mask(humans_s1, mask(mountains, humans_s1), 
                  inverse = TRUE, updatevalue = 4)
writeRaster(humans_s1, file.path(cnt_path, "blocks_spath_s1.tif"))

# Scenario 2
cropland_s2 <- cropland > 0.2
settlement_s2 <- settlement > 200
settlement_s2[isTRUE(settlement_s2)] <- 2
humans_s2 <- sum(cropland_s2, settlement_s2, na.rm = TRUE)
humans_s2 <- mask(humans_s2, mask(mountains, humans_s2), 
                  inverse = TRUE, updatevalue = 4)
writeRaster(humans_s2, file.path(cnt_path, "blocks_spath_s2.tif"))
```

#### Habitat cluster No.1

```{r}
cls_path <- file.path(cnt_exp_path, "cluster_1")

# Borders
pas_c1 <- pas %>% filter(cluster == 1)
bry <- st_union(pas_c1) %>% st_convex_hull() %>% 
    st_as_sf() %>% rename(geometry = x)

# current
curmap_block_c1 <- rast(
    file.path(cls_path, "human_block",
              "cum_curmap_human_block_cluster1.tif"))
curmap_block_c1 <- mask(curmap_block_c1, bry)
curmap_block_c1 <- norm_rast(curmap_block_c1)
writeRaster(curmap_block_c1, 
            file.path(cls_path, "c1_connectivity_scenario1.tif"))

curmap_block_complete_s1 <- rast(
    file.path(cls_path, "human_block_complete",
              "cum_curmap_human_block_complete_cluster1.tif"))
curmap_block_complete_s1 <- mask(curmap_block_complete_s1, bry)
curmap_block_complete_s1 <- norm_rast(curmap_block_complete_s1)
writeRaster(curmap_block_complete_s1, 
            file.path(cls_path, "c1_connectivity_scenario2.tif"))
```

#### Habitat cluster No.2

```{r}
cls_path <- file.path(cnt_exp_path, "cluster_2")

# Borders
pas_c2 <- pas %>% filter(cluster == 2)
bry <- st_union(pas_c2) %>% st_convex_hull() %>% 
    st_as_sf() %>% rename(geometry = x)

# current
curmap_block_c2 <- rast(
    file.path(cls_path, "human_block",
              "cum_curmap_human_block_cluster2.tif"))
curmap_block_c2 <- mask(curmap_block_c2, bry)
curmap_block_c2 <- norm_rast(curmap_block_c2)
writeRaster(curmap_block_c2, 
            file.path(cls_path, "c2_connectivity_scenario1.tif"))

curmap_block_complete_s2 <- rast(
    file.path(cls_path, "human_block_complete",
              "cum_curmap_human_block_complete_cluster2.tif"))
curmap_block_complete_s2 <- mask(curmap_block_complete_s2, bry)
curmap_block_complete_s2 <- norm_rast(curmap_block_complete_s2)
writeRaster(curmap_block_complete_s2, 
            file.path(cls_path, "c2_connectivity_scenario2.tif"))
```

#### Habitat cluster No.3

```{r}
cls_path <- file.path(cnt_exp_path, "cluster_3")

# Borders
pas_c3 <- pas %>% filter(cluster == 3)
bry <- st_union(pas_c3) %>% st_convex_hull() %>% 
    st_as_sf() %>% rename(geometry = x)

# current
curmap_block_c3 <- rast(
    file.path(cls_path, "human_block",
              "cum_curmap_human_block_cluster3.tif"))
curmap_block_c3 <- mask(curmap_block_c3, bry)
curmap_block_c3 <- norm_rast(curmap_block_c3)
writeRaster(curmap_block_c3, 
            file.path(cls_path, "c3_connectivity_scenario1.tif"))

curmap_block_complete_s3 <- rast(
    file.path(cls_path, "human_block_complete",
              "cum_curmap_human_block_complete_cluster3.tif"))
curmap_block_complete_s3 <- mask(curmap_block_complete_s3, bry)
curmap_block_complete_s3 <- norm_rast(curmap_block_complete_s3)
writeRaster(curmap_block_complete_s3, 
            file.path(cls_path, "c3_connectivity_scenario2.tif"))
```